# 实验名称
MPT_report

# 实验简介
research report on MPT

# 实验完成人
权周雨 

学号：202000460021 

git账户名称：baekhunee

# 前言

## 前缀树
前缀树（又称字典树），用于保存关联数组，其键（key）的内容通常为字符串。前缀树节点在树中的位置是由其键的内容所决定的，即前缀树的key值被编码在根节点到该节点的路径中。

如下图所示，图中共有6个叶子节点，其key的值分别为
（1）tc（2）tea（3）ted（4）ten（5）Ab（6）il

![image](https://user-images.githubusercontent.com/105578152/181406571-3a835e02-2622-42e0-b6f7-f2e759bcc972.png)

__优势__
1、相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)；然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。

2、相比于哈希表，在前缀树不会存在哈希冲突的问题

__劣势__
1、直接查找效率低下

前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。

2、可能造成空间浪费

当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。

## Merkle Tree
### 特点
1、默克尔树是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；

2、默克尔树叶子节点的value是数据项的内容，或者是数据项的哈希值；

3、非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的。

### 原理
在比特币网络中，merkle树是自底向上构建的，如下图所示：
![image](https://user-images.githubusercontent.com/105578152/181407089-4306e26a-0d3d-48ca-a2de-5e88f7d76f47.png)
将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。

__优势__
1、快速重哈希
默克尔树的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。

2、轻节点扩展
采用默克尔树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

__劣势__
存储空间开销大

# MPT
## 概述
Merkle Patricia Tree（又称Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

MPT树有以下几个作用：

1、存储任意长度的key-value键值对数据；

2、提供了一种快速计算所维护数据集哈希标识的机制；

3、提供了快速状态回滚的机制；

4、提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证。

## 节点分类
MPT树中，树节点可以分为以下几类：空节点、分支节点、叶子节点、扩展节点

### 空节点
空节点用来表示空串。

### 分支节点

分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点

与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换，将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key’的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是在一定程度上增加了树高。

分支节点的孩子列表中，最后一个元素是用来存储自身的内容。

此外，每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：

·节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；

·脏标志：当一个节点被修改时，该标志位被置为1；

·诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多。

### 叶子节点&&扩展节点

关键的字段为：

Key：用来存储属于该节点范围的key；

Val：用来存储该节点的内容；

其中Key是MPT树实现树高压缩的关键！

如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如下图：

针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。

例如图中我们将红线所圈的节点称为node1, 将紫色线所圈的节点称为node2。node1与node2共享路径前缀t，但是node1在插入时，树中没有与oast有共同前缀的路径，因此node1的key为oast，实现了编码路径的压缩。

这种做法可以提高节点的查找效率，避免过多的磁盘访问，并且减少存储空间浪费，避免存储无用的节点。

## 安全的MPT
以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

查询一个节点可能会需要许多次IO读取，效率低下；

系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；

所有的key其实是一种明文的形式进行存储；

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(sha3(key), value)

__优势__

1、传入MPT接口的key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；

__劣势__

1、每次树操作需要增加一次哈希计算；

2、需要在数据库中存储额外的sha3(key)与key之间的对应关系。

